<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <pre>
    1. 你在设计组件库时，如何决定组件的粒度？
    2. 如何避免组件库中的样式冲突？
    3. 请解释什么是树摇（Tree Shaking）？组件库如何受益于它？
    4. 你如何设计一个支持多主题的组件库？
    5. 在构建组件库时，你会如何处理国际化问题？
    6. 如何确保组件库在不同的浏览器中都能正常工作？
    7. 你使用过哪些技术或工具来测试组件库？
    8. 请描述一次你在使用或开发组件库时遇到的困难及如何解决的?
    9. 在使用CSS-in-JS、CSS模块化或其他样式解决方案时，有哪些优缺点？
    10. 如何在组件库中处理依赖库的版本管理问题？

    业务组件的二次封装其实就是对通用组件库中多个组件的组合封装，组合在一起使用组成一个
    大的业务功能；比如筛选列表，其中有选择日期，输入单号，选择类型等等，需要把选择框
    输入框，日期弹框等等都封装在一起，通过配置数据去显示展示，在输入或者选择之后又有
    对应的事件，那么需要再把这些事件发送到外层组件进行使用；封装组件库的主要一点就是为了
    复用性，提高开发效率，因为要考虑到它的通用性，易用性，可扩展性和可易维护性；

    1. 你在设计组件库时，如何决定组件的粒度？
      组件的细粒度不能过大也不能过小，过大的话就会导致组件过于复杂，使用起来也比较麻烦，
      过小的话就会导致组件过于琐碎，增加了维护和开发成本；
      我主要从以下几点考虑组件的粒度：
      - 单一原则：一个组件就实现一个功能；
      - 复用性和通用性：尽可能通过传递一些属性就能满足开发者的需求，比如筛选列表，配置不同的
        数据类型，显示对应的选择框；
      - 降低耦合度：如果多个组件之间有强耦合，那么就把它们封装成一个大的组件；
      - 组件的状态管理：多个组件需要共享状态，那么就把它们封装在一起，在外层统一管理这些组件的状态
      - 复杂性和可维护性：一个组件不应多余复杂，太复杂的话维护起来比较困难，对于复杂的组件应该再进行
                        拆分成更小的组件，通过小组件进行组合；
      - 性能： 减少不必须要的渲染；
    
      2. 如何避免组件库中的样式冲突？
        - 命名空间或BEM： 比如根据组件的名称为前缀进行命名，但是这不是一个好的办法，因为还是会导致命名冲突；
        - css模块：根据打包工具提供的一些转换工具，在编译的时候可以将选择器加上hash值编译成全局唯一的选择器；
        - css-in-js: 把Css放在js中使用，优点就是可以在js中定义一些Css变量或样式，缺点它是在运行时进行设置样式
                    因此会消耗性能；
        - shadow DOM: web组件，通过它来包裹dom元素，这样就有属于自己的样式，dom和js;
        - vue中的scoped: 在编译阶段利用工具给元素添加自定义属性，并且给元素上对应的css选择器也添加自定义属性选择器；

      3. 请解释什么是树摇（Tree Shaking）？组件库如何受益于它？
        tree shaking: 抖动掉未使用的代码从而较少包的体积，它依赖于es6的模块化，并且在编译的时候通过静态分析在依赖的
        文件中找出导入或者使用的变量进行标记，在最终打包的时候剔除掉未使用的代码；

        在开发组件的时候我们应该使用es6模块化，并且使用命名导出或者导入，而不是默认导出或者导入，并且较少组件的副作用；
        这样在开发者打包的时候只打包他所用到的组件而非整个组件库中的组件，这样可以较少包的体积提升访问效率；

      4. 你如何设计一个支持多主题的组件库？
        根据设计稿中的全部组件提取主题的颜色，比如字体颜色，背景色，边框颜色，字体大小等，通过全局变量来设置这些属性的值，
        定义几组主题样式变量，切换主题的时候根据js动态的切换；同时也需要提供一个方法供开发者自定义主题，给方法
        传递一组样式的值，执行这个方法就可以切换主题了；

      5. 在构建组件库时，你会如何处理国际化问题？
        - 分离文本，把用户可见的文本都提取出来，单独放在一个文件中，通过key-value的形式管理和使用，这样方便翻译；
        - 使用第三方国际化库，比如i18next
        - 支持动态的语言切换，并且不会刷新页面，第三方库都会提供一些切换的功能；
        - 动态的内容使用占位符
        - 传递给组件的属性文本，翻译之后的内容
        - 组件的国际语言，一般组件库都支持多语言，在二次封装的时候可以通过组件库提供的方法在进行统一的封装暴露给开发者进行动态切换
  
      6. 如何确保组件库在不同的浏览器中都能正常工作？
        - 根据产品的用户群体，收集需要支持的浏览器版本和型号
        - 在开发组件的时候需要使用标准化的api,避免使用实验性的api;
        - 使用polyfills来确保新特性去兼容旧的浏览器
        - Css方面要给一些新特性加一些前缀来兼容不同的浏览器，可以使用autoprefixer自动添加
        - 检测一些新特性的浏览器的支持情况(Modernizr)，如果必要用需要写兼容性的方法，或者在开发文档中进行明确的标注支持的浏览器版本和型号；
        - 使用响应式布局，确保适配不同的屏幕；
        - 进行主流浏览器和手机型号上进行测试，尽可能早的发现问题；
        - 定期收集用户的反馈，及时的进行修复
        - 定期的更新和维护

      7. 你使用过哪些技术或工具来测试组件库？
        - 单元测试使用jest，测试每个功能模块是否符合预期
        - 集成测试使用cypress
        - 手动测试，查看ui是否有问题，和各个浏览器，设备型号的支持程度
        - 性能测试通过lighthouse，测试性能
        通过对组件库的功能，ui样式，性能，兼容性测试来确保组件库的质量和可靠性
      
      8. 请描述一次你在使用或开发组件库时遇到的困难及如何解决的?
        - 组件不满足当前需要，需要进行扩展，那就修改现有组件，但是不能影响之前的使用者，
          所以扩展的时候要写兼容性写法，之前的写法要支持，新增的功能也得支持

        - 不同项目使用的主题样式不一样，文档中写明切换主题的属性，开发者可以给body或html的标签添加
          自定义属性，并且在此属性下修改主题样式的值，这样就可以切换想要的主题了
        
      9. 在使用CSS-in-JS、CSS模块化或其他样式解决方案时，有哪些优缺点？
        - css-in-js: 优点实现样式隔离，并且可以通过js动态的定义值；缺点：它是在运行时，
                      每次渲染会都动态的进行添加样式，消耗性能；
        
        - css模块化：优点实现了样式隔离，它是在编译的时候给每个选择器添加一个唯一的hash值，并且同步修改了元素
                    上的选择器，相比css-in-js性能有提升；缺点需要打包功能和相应的插件进行处理；

        - shadow DOM：优点实现了样式隔离，每个shadow dom都有自己的js,css和html,但是写法比较复杂

      10. 如何在组件库中处理依赖库的版本管理问题？
        - 通过peerDependencies管理依赖包，这样就需要使用者去安装自定版本的依赖，这样就可以做到组件库中的依赖
          和项目中使用的相同的依赖都是统一的版本；并且也解决了重复改装依赖的问题；

      11. dependencies和devDependencies和peerDependencies的区别?
        - dependencies：是生产和开发环境都需要的依赖
        - devDependencies: 是开发环境需要的依赖，不会被引用到生产环境
        - peerDependencies: 项目本身不进行安装的依赖，是告知开发者需要安装的依赖，一般用于组件库的发开，确保
                            项目中使用的依赖和组件库中使用的依赖都是同一个；npm2中会根据peerDependencies列出
                            的依赖进行自动安装，安装到项目的node_modules中，而npm3不会自动安装，会进行提示需要
                            开发者手动安装；
  </pre>
</body>
</html>