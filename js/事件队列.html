<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    /*
        事件队列

        1. 执行栈
           一个数据结构。用于存放各种函数的执行环境，函数调用前创建执行环境，然后推入到执行栈中，
           函数调用执行完毕之后就推出执行栈并且销毁它的执行环境；

           js引擎永远都是执行执行栈的顶部函数
           执行栈中只有一个正在执行的函数和这个函数相关的其他函数

        2. 异步函数
            某些函数的回调不会被立即执行，需要等到一定的时机才会去执行，比如定时器，ajax请求
            异步函数的执行条件会被宿主环境所控制(js运行的环境就是宿主环境)

        3. 浏览器宿主环境包含5个线程：
            3.1 js引擎： 负责执行执行栈顶层的代码
            3.2 GUI渲染线程： 负责渲染页面
            3.3 事件监听线程： 负责监听各种事件
            3.4 计时线程： 负责计时
            3.5 网络线程： 负责网络通信

        4. 任务队列(浏览器两种)
            4.1 宏任务队列
                ajax请求回调，setTimeout回调,setInterVal回调,事件回调，
            4.2 微任务队列
                promise回调，MutationObserver

        5. 事件循环
           当异步函数执行的时候，它本身会在执行栈中执行，然后把相应的执行回调条件添加到宿主环境中的相应
           的线程中，等到满足条件之后，线程中会把回调函数添加到相应的任务队列中，当执行栈为空的时候，首先
           微任务队列会把它里面的回调挨个推向执行栈执行，当微任务执行完毕之后，宏任务队列才把它里面的一个回调推
           向执行栈中执行；执行完再清空微任务队列，再执行下个宏任务队列中的一个回调(执行栈，宿主环境，任务队列相互配合就是事件循环)

    
    */

    console.log(1)
    setTimeout(()=>{
        console.log(2)
    })
    console.log(3)

    // 1 3 2
    /*
     解析：
        1. console.log(1)执行，它的执行环境被推向执行栈中执行

        2. 执行完毕之后log(1)的执行环境被推出执行栈，setTimeout函
           数执行，它的执行环境被推向执行栈中执行，发现他是异步函数，
           宿主环境中的计时线程按照条件开始计时，setTimeout执行完
           毕之后被推出执行栈，

        3. log(3)函数执行，执行环境被推入执行栈中，log(3)函数执行完
           毕之后推出执行栈，宿主环境中的计时线程等到条件满足，就把
           回调推向到宏任务队列中，此时执行栈已经为空了，首先微任务
           检索是否有回调需要执行，没有宏任务队列就把定时器的回调推
           向执行栈执行，回调函数的执行环境推入执行栈执行，执行log(2)，
           继续把log(2)函数的执行环境推向执行栈中，log(2)执行完毕之后，
           被推出执行栈，回调函数执行完毕被推出执行栈
    */
    
    </script>
</body>
</html>